<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../../../application/modules/st/resources/js/st.js - Sourcetrak</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Sourcetrak" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/aa.html">aa</a></li>
                                <li><a href="../classes/act_on.html">act_on</a></li>
                                <li><a href="../classes/Collections.Activities.html">Collections.Activities</a></li>
                                <li><a href="../classes/Collections.DomainSets.html">Collections.DomainSets</a></li>
                                <li><a href="../classes/Collections.Locations.html">Collections.Locations</a></li>
                                <li><a href="../classes/Collections.PaginatedActivities.html">Collections.PaginatedActivities</a></li>
                                <li><a href="../classes/Collections.PaginatedLocations.html">Collections.PaginatedLocations</a></li>
                                <li><a href="../classes/Collections.Patterns.html">Collections.Patterns</a></li>
                                <li><a href="../classes/Collections.Pools.html">Collections.Pools</a></li>
                                <li><a href="../classes/Collections.ReplacementNumbers.html">Collections.ReplacementNumbers</a></li>
                                <li><a href="../classes/Collections.Routing.html">Collections.Routing</a></li>
                                <li><a href="../classes/Collections.Schedules.html">Collections.Schedules</a></li>
                                <li><a href="../classes/Collections.SubCollection.html">Collections.SubCollection</a></li>
                                <li><a href="../classes/hubspot.html">hubspot</a></li>
                                <li><a href="../classes/Mixins.AudioFileUploadBtn.html">Mixins.AudioFileUploadBtn</a></li>
                                <li><a href="../classes/Mixins.Autosave.html">Mixins.Autosave</a></li>
                                <li><a href="../classes/Mixins.Autoset.html">Mixins.Autoset</a></li>
                                <li><a href="../classes/Mixins.ClientPagination.html">Mixins.ClientPagination</a></li>
                                <li><a href="../classes/Mixins.HighlightInvalid.html">Mixins.HighlightInvalid</a></li>
                                <li><a href="../classes/Mixins.Loading.html">Mixins.Loading</a></li>
                                <li><a href="../classes/Mixins.Transform.html">Mixins.Transform</a></li>
                                <li><a href="../classes/Models.Activity.html">Models.Activity</a></li>
                                <li><a href="../classes/Models.Location.html">Models.Location</a></li>
                                <li><a href="../classes/Models.Pattern.html">Models.Pattern</a></li>
                                <li><a href="../classes/Models.Pool.html">Models.Pool</a></li>
                                <li><a href="../classes/Models.Routing.html">Models.Routing</a></li>
                                <li><a href="../classes/Models.Schedule.html">Models.Schedule</a></li>
                                <li><a href="../classes/Models.State.html">Models.State</a></li>
                                <li><a href="../classes/Models.SubModel.html">Models.SubModel</a></li>
                                <li><a href="../classes/op.html">op</a></li>
                                <li><a href="../classes/Validator.html">Validator</a></li>
                                <li><a href="../classes/Views.Activity.html">Views.Activity</a></li>
                                <li><a href="../classes/Views.ActivityAdd.html">Views.ActivityAdd</a></li>
                                <li><a href="../classes/Views.ActivityCreate.html">Views.ActivityCreate</a></li>
                                <li><a href="../classes/Views.ActivityDestroy.html">Views.ActivityDestroy</a></li>
                                <li><a href="../classes/Views.ActivityDisplay.html">Views.ActivityDisplay</a></li>
                                <li><a href="../classes/Views.ActivityEdit.html">Views.ActivityEdit</a></li>
                                <li><a href="../classes/Views.ActivityEditAdvanced.html">Views.ActivityEditAdvanced</a></li>
                                <li><a href="../classes/Views.ActivityList.html">Views.ActivityList</a></li>
                                <li><a href="../classes/Views.ActivityPool.html">Views.ActivityPool</a></li>
                                <li><a href="../classes/Views.ActivityPoolEdit.html">Views.ActivityPoolEdit</a></li>
                                <li><a href="../classes/Views.AdvancedOptionsModal.html">Views.AdvancedOptionsModal</a></li>
                                <li><a href="../classes/Views.CopyToClipboard.html">Views.CopyToClipboard</a></li>
                                <li><a href="../classes/Views.DeleteLocationModal.html">Views.DeleteLocationModal</a></li>
                                <li><a href="../classes/Views.DomainSetItem.html">Views.DomainSetItem</a></li>
                                <li><a href="../classes/Views.DomainsPopover.html">Views.DomainsPopover</a></li>
                                <li><a href="../classes/Views.EditPoolToolbar.html">Views.EditPoolToolbar</a></li>
                                <li><a href="../classes/Views.Graph.html">Views.Graph</a></li>
                                <li><a href="../classes/Views.listControls.html">Views.listControls</a></li>
                                <li><a href="../classes/Views.LocationItem.html">Views.LocationItem</a></li>
                                <li><a href="../classes/Views.LocationsList.html">Views.LocationsList</a></li>
                                <li><a href="../classes/Views.Main.html">Views.Main</a></li>
                                <li><a href="../classes/Views.Modal.html">Views.Modal</a></li>
                                <li><a href="../classes/Views.Modal2.html">Views.Modal2</a></li>
                                <li><a href="../classes/Views.ModalPageView.html">Views.ModalPageView</a></li>
                                <li><a href="../classes/Views.Numbers.html">Views.Numbers</a></li>
                                <li><a href="../classes/Views.PageView.html">Views.PageView</a></li>
                                <li><a href="../classes/Views.Poolbar.html">Views.Poolbar</a></li>
                                <li><a href="../classes/Views.PoolsDashboard.html">Views.PoolsDashboard</a></li>
                                <li><a href="../classes/Views.PoolsList.html">Views.PoolsList</a></li>
                                <li><a href="../classes/Views.PoolsListItem.html">Views.PoolsListItem</a></li>
                                <li><a href="../classes/Views.Popover.html">Views.Popover</a></li>
                                <li><a href="../classes/Views.SearchBox.html">Views.SearchBox</a></li>
                                <li><a href="../classes/Views.SnippetModal.html">Views.SnippetModal</a></li>
                                <li><a href="../classes/Views.Toolbar.html">Views.Toolbar</a></li>
                                <li><a href="../classes/Views.VersionHashError.html">Views.VersionHashError</a></li>
                                <li><a href="../classes/Views.Wizard.html">Views.Wizard</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Carbon.html">Carbon</a></li>
                                <li><a href="../modules/Integration.html">Integration</a></li>
                                <li><a href="../modules/SourceTrak.html">SourceTrak</a></li>
                                <li><a href="../modules/Sourcetrak.html">Sourcetrak</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ../../../application/modules/st/resources/js/st.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// SourceTrak
(function (window) {
    var _st  = window._st,
        _stk = window._stk,
        _st_num_url = window._st_num_url === undefined ? &#x27;https://st1.ifbyphone.com/st/&#x27; : window._st_num_url,
        _st_locations_url = window._st_locations_url === undefined ? &#x27;https://st1.ifbyphone.com/st/locations&#x27; : window._st_locations_url,
        _st_log_url = window._st_log_url === undefined ? &#x27;https://st2.ifbyphone.com/st/log&#x27; : window._st_log_url,
        _st_sync    = window._st_sync    === undefined ? false : window._st_sync,
        _st_debug   = window._st_debug   === undefined ? false : window._st_debug,
        _st_ref     = window._st_ref     === undefined ? false : window._st_ref,
        _st_loc     = window._st_loc     === undefined ? false : window._st_loc,
        _st_format  = window._st_format  === undefined ? true  : window._st_format,
        version     = 1,
        d         = null,
        heartbeat = null,
        hasHardExpired = false,
        uaDispatched   = false,
        uaSet          = false,
        hasLoggedPageHit       = false,
        hasLoggedPageHitWithUA = false,
        dispatchCount     = 0,
        isCookieSupported = 0,
        integrationsCount = 0,
        integrationsData  = [],
        ready = false,
        ua,
        uac,
        isMobile,
        pageHitTimeout,
        pageHitSuccessful,

        // refactored locations vars
        locationsCache = {
            se: 600,
            main: {},
            index: {},
            locations: [],
            ignoreLocations: [],
            rendered: [],
            renderedRawMln: []
        },
        locationsFound = [],

        // indicates locations have been found but still waiting on initial number request
        locationsQueued = false,

        // queue that can have function callbacks pushed to it
        // that will be executed in random order on page ready
        // or immediately if page is ready
        // ONLY readyQueuePush to push to this array!
        readyQueue = [];

    // initialization function
    _st.i = function (data, isCookieData) {
        var currentTime = getCurrentTimestamp();

        if (hasLoggedPageHit) {
            pageHitSuccessful = true;
        }

        d = applyDefaults(data);

        d.ht = d.ht ? d.ht : createExpiresTimestamp(d.he);

        // pull in UA data if it is available (necessary due to unpredictable timing of receiving UA data)
        if (uaSet) {
            d.ua = ua;
            d.uac = uac;
        }

        if (d.et &lt; currentTime || d.ht &lt; currentTime) {
            log(&#x27;soft or hard expired on PAGE LOAD, updating soft expires and refreshing number&#x27;);
            d.et = createExpiresTimestamp(d.se);

            refreshNumber();
            return;
        } else {
            d.et = createExpiresTimestamp(d.se);
        }

        // render number to screen only in asynchronous mode, on dom ready
        if (!_st_sync) {
            readyQueuePush(render);
        }

        // set cookie
        setDataCookie();

        if (isCookieData) {
            pushData(buildMeta(), null, true);

            // Explicitly flag when we record a page hit.
            // This is necessary information for making decisions about when to make a follow up with additional data.
            hasLoggedPageHit = true;
        }

        // There can be timing issues where a page hit is logged, and the UA is set, but it was not logged with the
        // page hit. This will address that scenarior immediately in the init
        if (uaSet &amp;&amp; hasLoggedPageHit &amp;&amp; !hasLoggedPageHitWithUA) {
            pushUA();
        }

        // start heartbeat
        startHeartbeat();

        // begin integrations search
        if (d.integrations &amp;&amp; d.integrations.length) {
            var integrations = [];

            // get subset of integrations to run
            for (var i = 0; i &lt; d.integrations.length; i++) {
                var integration = window._st.getIntegration(d.integrations[i]);

                integrations.push(integration);
            }

            // start the search loop
            dispatchIntegrations(integrations);
        }

        log(d);

        // refresh locations if queued
        if (d.ml === 1 &amp;&amp; locationsQueued) {
            processLocations();
        }

        // for browsers that support it, create our custom event to notify when all the _st data is available
        if (document.createEvent) {
            var stEvent = document.createEvent(&#x27;Event&#x27;);
            stEvent.initEvent(&#x27;_st_ready&#x27;, true, false);
            document.dispatchEvent(stEvent);
        }

        // let polling scripts know we&#x27;re ready
        ready = true;
    };

    // expects data to match the format returned from the server
    /*
    data = {
        se: 600,
        mln: {
            5554441123: {
                stn: 2123245577,
                sgn: 0
            },
            {...},
            {...}
        }
    }
    */
    _st.l = function(data, isCookieData) {
        // compare the list we sent with what we received
        // if we didnt receive a number we sent, then we remove it from our list of real locations
        // and we store it for future reference
        // now we know what a real locations
        if (isCookieData) {
            for (var i = 0; i &lt; data.mln.length; i++) {
                locationsCache.rendered.push(data.mln[i].stn);
                locationsCache.renderedRawMln.push(data.mln[i]);
            }
        }
        else {
            for (var j = 0; j &lt; locationsFound.length; j++) {
                var num = locationsFound[j],
                    validLoc = null;

                for (var k = 0; k &lt; data.mln.length; k++) {
                    if (num == data.mln[k].ntr) {
                        validLoc = data.mln[k];
                    }
                }

                if (validLoc) {
                    locationsCache.rendered.push(validLoc.stn);
                    locationsCache.renderedRawMln.push(validLoc);
                    locationsCache.add(validLoc);
                }
                else {
                    locationsCache.ignore(num);
                }
            }
        }

        renderLocations(locationsCache.renderedRawMln);

        // if rendered from cookie, log presence of locations immediately through a heartbeat
        if (isCookieData) {
            beat();
        }
    };

    // Allow one to retrieve the locationsCache object
    _st.getLocationsCache = function() {
        return locationsCache;
    };

    // Allow pushing of meta key:value pairs
    _st.push = function (d, c) {
        pushData(d, c);
    };

    _st.getInfo = function () {
        return  {
            bid: d.bid,
            pid: d.pid,
            stn: d.stn,
            ntr: d.ntr,
            rc:  d.rc,
            rid: d.rid,
            et:  d.et,
            ht:  d.ht,
            se:  d.se,
            he:  d.he,
            h:   d.h,
            a:   d.a,
            m:   d.m,
            ua:  d.ua,
            uac: d.uac,
            ml:  d.ml,
            v:   d.v,
            sfx: d.sfx
        };
    };

    _st.getNumber = function () {
        return d.stn;
    };

    _st.getFormattedNumber = function (srcNum) {
        return srcNum ? matchFormat(srcNum, srcNum, d.stn) : formatPhone(d.stn);
    };

    // used to render the number in synchronous mode
    _st.renderNumber = function () {
        document.write(formatPhone(d.stn));
    };

    // This will set the google analytics data within both the _st namespace, as well as the data object.
    // Setting it in both places is necessary due to the multiple timing/execution paths that can happen.
    // This will also initiate the log request for analytics if the script has made it all the way through _st.i
    // without logging the analytics.
    _st.setUA = function (tracker, clientId) {
        ua = tracker;
        uac = clientId;
        uaSet = true;

        if (d != null) {
            d.ua = ua;
            d.uac = uac;
            setDataCookie();
        }

        if (uaSet &amp;&amp; hasLoggedPageHit &amp;&amp; !hasLoggedPageHitWithUA) {
            pushUA();
        }
    };

    _st.setDebugMode = function (mode, forceIsMobile) {
        _st_debug = mode;

        // allow mobile devices to force desktop mode and use the console
        // useful for debugging iOS devices that are connected to a computer using mobile inspector
        if (forceIsMobile !== undefined) {
            isMobile = forceIsMobile;
        }
    };

    _st.getIntegration = function (name) {
        for (var i = 0; i &lt; this.integrations.length; i++) {
            if (this.integrations[i].name() === name) {
                return this.integrations[i];
            }
        }
    };

    _st.getCookie = function (name) {
        // TODO: investigate return state of RegEx for different scenarios, see if the OR null is necessary
        return decodeURIComponent(
                    document.cookie.replace(
                        new RegExp(&quot;(?:(?:^|.*;)\\s*&quot; + encodeURIComponent(name).replace(/[\-\.\+\*]/g, &quot;\\$&amp;&quot;) + &quot;\\s*\\=\\s*([^;]*).*$)|^.*$&quot;),
                    &quot;$1&quot;)
                ) || null;
    };

    _st.isReady = function () {
        return ready;
    };
    _st.log = function () {
        log.apply(this, arguments);
    };

    // Apply defaults for any undefined properties on the data object
    function applyDefaults(data) {
        var defaults = {
                sfx: &#x27;&#x27;,
                ntr: &#x27;&#x27;,
                rid: &#x27;&#x27;,
                rc:  &#x27;&#x27;,
                m:   &#x27;&#x27;,
                v:   &#x27;&#x27;,
                a:   0,
                ml:  0,
                h:   60,
                he:  10800,
                se:  600,
                sgn: 0,
                et: createExpiresTimestamp(600),
                ht: createExpiresTimestamp(10800),
                integrations: []
            };

        for (var prop in defaults) {
            if (data[prop] === undefined) {
                data[prop] = defaults[prop];
            }
        }

        return data;
    }

    function getCurrentTimestamp() {
        return parseInt((new Date().getTime()) / 1000, 10);
    }

    function createExpiresTimestamp(interval) {
        return parseInt(((new Date().getTime()) / 1000) + parseInt(interval, 10), 10);
    }

    // Build basic meta data
    function buildMeta() {
        var ws = window.screen,
            doc = document,
            dEl =  doc.documentElement,
            dBody = doc.body,
            ref = _st_ref ? _st_ref : doc.referrer,
            loc = _st_loc ? _st_loc : doc.location.href,
            meta;

        // build the base params that will be sent with each meta request
        meta = &quot;_stk=&quot; + _stk
                + &quot;&amp;dr=&quot; + encodeURIComponent(ref)
                + &quot;&amp;dl=&quot; + encodeURIComponent(loc)
                + &quot;&amp;dt=&quot; + encodeURIComponent(doc.title)
                + &quot;&amp;vp=&quot; + encodeURIComponent(
                                (dEl.clientWidth ? dEl.clientWidth : dBody.clientWidth)
                                + &quot;x&quot;
                                + (dEl.clientHeight ? dEl.clientHeight : dBody.clientHeight)
                           )
                + &quot;&amp;sr=&quot; + encodeURIComponent(ws.width + &quot;x&quot; + ws.height);

        // include additional params such as bid, pid, and stn if we have them
        if (d &amp;&amp; d.bid) {
            meta += &quot;&amp;bid=&quot; + d.bid;

            if (d.pid) {
                meta += &quot;&amp;pid=&quot; + d.pid
                      + &quot;&amp;stn=&quot; + d.stn
                      + &quot;&amp;sgn=&quot; + d.sgn;
            }
        }

        // include the customer provided unique ID if it exists.
        if (window.hasOwnProperty(&#x27;_st_custom_id&#x27;)) {
            meta += &quot;&amp;cid=&quot; + window._st_custom_id;
        }
        else if (window.hasOwnProperty(&#x27;_ibp_unique_id&#x27;)) {
            // check for deprecated format
            meta += &quot;&amp;cid=&quot; + window._ibp_unique_id;
        }

        // include the customer provided unique value if it exists.
        if (window.hasOwnProperty(&#x27;_st_custom_value&#x27;)) {
            meta += &quot;&amp;cv=&quot; + window._st_custom_value;
        }
        else if (window.hasOwnProperty(&#x27;_ibp_custom&#x27;)) {
            // check for deprecated format
            meta += &quot;&amp;cv=&quot; + window._ibp_custom;
        }

        if (uaSet) {
            meta += &quot;&amp;ua=&quot; + ua
                  + &quot;&amp;uac=&quot; + uac;
            log(&#x27;UA SENT with meta&#x27;);

            // Explicitly flag when we record a page hit.
            // This is necessary information for making decisions about when to make a follow up with additional data.
            hasLoggedPageHitWithUA = true;

        } else {
            log(&#x27;UA NOT sent with meta&#x27;);
        }

        return meta;
    }

    // Render SourceTrak Number
    function render() {
        // split up the number to be replaced, in order to easily set its parts into our regex below
        var ntr = splitPhone( (hasHardExpired ? d.stn : d.ntr) ),
            // Setup our regex that is used to search for a given number on the page and replace it with our ST number
            re = new RegExp(&quot;(1[-. ]?)?\\(?(&quot; + ntr[0] + &quot;)\\)?[-. ]?(&quot; + ntr[1] + &quot;)[-. ]?(&quot; + ntr[2] + &quot;)&quot;, &quot;g&quot;),
            // format the raw SourceTrak number in a nice readable manner for the screen. Optionally, wrap it in a tel anchor.
            rawNum = hasHardExpired ? d.m : d.stn,
            num = formatPhone(rawNum),
            ridEl,
            rcEl,
            rcElLength,
            jsReplace,
            strReplace;

        // figure out if we&#x27;re matching formats or using default
        if (_st_format) {
            // this one handles the callback for replace.js
            jsReplace = function (portion, match) {
                return matchFormat(portion.text, match[0], rawNum);
            };

            // this one is for the native String replace method
            strReplace = function (portion) {
                // for String.replace, the last argument is the full match term
                var match = arguments[arguments.length - 1];

                return matchFormat(portion, match, rawNum);
            };
        } else {
            jsReplace = strReplace = num;
        }

        if (d.ntr !== &#x27;&#x27; &amp;&amp; d.ntr !== undefined) {
            // replace all instances of a specifed phone number on the page with the SourceTrak number
            var options  = {
                    find: re,
                    replace: jsReplace,
                    rawNum: rawNum,
                    wrapInATag: (d.a === 1 &amp;&amp; isMobile)
                },
                titleEls = _st.Sizzle(&#x27;[title]&#x27;),
                linkEls  = _st.Sizzle(&#x27;a[href*=&quot;tel&quot;]&#x27;);

            // replace in body
            _st.replace(document.body, options);

            // replace in page title
            document.title = document.title.replace(re, strReplace);

            // replace in title attributes
            for (var i = 0; i &lt; titleEls.length; i++) {
                var el    = titleEls[i],
                    title = el.getAttribute(&#x27;title&#x27;);

                el.setAttribute(&#x27;title&#x27;, title.replace(re, strReplace));
            }

            // replace in tel links
            for (var j = 0; j &lt; linkEls.length; j++) {
                var el   = linkEls[j],
                    href = el.getAttribute(&#x27;href&#x27;);

                el.setAttribute(&#x27;href&#x27;, href.replace(re, strReplace));
            }
        }

        // use the default number format since we don&#x27;t know what format they might prefer
        if (d.rid !== &#x27;&#x27; &amp;&amp; d.rid !== undefined) {
            // insert phone number in an element that matches a specified ID
            ridEl = _st.Sizzle(&quot;#&quot; + d.rid);
            if (ridEl.length) {
                ridEl[0].innerHTML = num;
            }
        }

        if (d.rc !== &#x27;&#x27; &amp;&amp; d.rc !== undefined) {
            // insert number in all elements that have a CSS class that matches
            rcEl = _st.Sizzle(&quot;.&quot; + d.rc);
            rcElLength = rcEl.length;

            for (var i = 0; i &lt; rcElLength; i++) {
                rcEl[i].innerHTML = num;
            }
        }

        if (d.sfx !== &#x27;&#x27; &amp;&amp; d.sfx !== undefined) {
            // insert phone suffix in all elements that have a CSS class that matches st-sfx
            sfxEl = _st.Sizzle(&quot;.st-sfx&quot;);
            sfxElLength = sfxEl.length;

            for (var i = 0; i &lt; sfxElLength; i++) {
                sfxEl[i].innerHTML = d.sfx;
            }
        }
    }

    // split the phone number into its 3 parts [aaa, bbb, cccc]
    function splitPhone(phone) {
        return [phone.substr(0,3), phone.substr(3, 3), phone.substr(6, 4)];
    }

    // Format phone number with default formatting and optionally wrap in tel enabled anchor tag,
    // for class and ID replacement
    function formatPhone(phone) {
        var p = splitPhone(phone),
            formattedPhone = &quot;(&quot; + p[0] + &quot;) &quot; + p[1] + &quot;-&quot; + p[2];

        // Format as vanity number when main number is displayed
        if (d.v &amp;&amp; (d.m === phone)) {
            formattedPhone = d.v;
        }

        // If anchor tags are enabled and this is a mobile device
        // wrap the number in a tel enabled anchor tag for class and ID replacement
        if (d.a === 1 &amp;&amp; isMobile) {
            // Add a data attribute that lets us know WE wrapped the number in an anchor tag
            formattedPhone = &#x27;&lt;a href=&quot;tel:+1&#x27; + phone + &#x27;&quot; data-st-f=&quot;&quot;&gt;&#x27; + formattedPhone + &#x27;&lt;/a&gt;&#x27;;
        }

        return formattedPhone;
    }

    // accepts a number or a portion of a number and returns the
    // SourceTrak number or the specified portion in the same format
    function matchFormat(portion, srcNum, stNum) {
        var porLength = portion.length,
            begPos    = srcNum.indexOf(portion),
            endPos    = begPos + porLength,
            srcLength = srcNum.replace(/\D/g, &#x27;&#x27;).length,
            srcArr    = srcNum.split(&#x27;&#x27;),
            format    = [],
            stArr;

        // add country code if srcNum has it
        stNum = srcLength === 11 ? &#x27;1&#x27; + stNum : stNum;
        stArr = stNum.split(&#x27;&#x27;);

        // find the delimiting characters and their positions in srcNum
        for (var i = 0; i &lt; srcArr.length; i++) {
            var chr = srcArr[i];

            if ((/\D/).test(chr)) {
                format.push({pos: i, chr: chr});
            }
        }

        // insert the delimiting characters at their positions in stNum
        for (var j = 0; j &lt; format.length; j++) {
            stArr.splice(format[j].pos, 0, format[j].chr);
        }

        // return the portion of the number as a string
        return stArr.join(&#x27;&#x27;).slice(begPos, endPos);
    }


/******************************************
 * LOCATIONS
 ******************************************/
/*
    FIND
    1. FIND THE LOCATIONS (IF I AM MULTI LOCATION SITE)

    TRANSMIT
    1. CLEAN THE LOCATIONS (REMOVE THE NORMAL MAIN NUMBER)
    2. REMOVE KNOWN NUMBERS THAT ARE NOT LOCATIONS OR MAIN (STORED IN A LOCATIONS COOKIE)
    3. TRANSMIT CLEAN LOCATIONS (IF I AM MULTI LOCATION SITE)

    RECEIVE
    1. RECEIVE LOCATION NUMBERS
    2. STORE LOCATIONS IN A COOKIE

    RENDER
    1. REPLACE STATIC LOCATION NUMBERS WITH DYNAMIC NUMBERS
*/

    // initialize the locations cache
    locationsCache.init = function(data) {
        var cookie = window._st.getCookie(&#x27;_st_l&#x27;);

        this.main.ntr = data.ntr;
        this.main.stn = data.stn;
        this.main.m   = data.m;
        this.lastPersist = 0;
        this.queuePersist = null;
        this.cacheLimit = 20;
        if (cookie) {
            this.buildFromCookie(cookie);
        }
    };

    // rebuild the locations cache based on the data in a cookie
    locationsCache.buildFromCookie = function(cookie) {
        // expects a cookie to be returned using our get cookie function
        // which returns null if no valid cookie found
        if (cookie === null) {
            return;
        }

        // clear out the locations array
        this.locations.length = 0;

        // first split between locations and ignored
        var splitCookie = cookie.split(&#x27;|&#x27;);

        //deal with real locations
        if (splitCookie[0].length &gt; 0) {
            var flatObjArr = splitCookie[0].split(&#x27;.&#x27;),
                flatObjArrLegnth;

            this.se = flatObjArr.shift();

            flatObjArrLength = flatObjArr.length;

            for (var i = 0; i &lt; flatObjArrLength; i++) {
                var flatObj = flatObjArr[i].split(&#x27;,&#x27;),
                    data = {
                        ntr: flatObj[0],
                        stn: flatObj[1],
                        sgn: flatObj[2],
                        et:  flatObj[3]
                    };

                // only push the location if it is within the cacheLimit
                if (flatObj.length &gt; 0 &amp;&amp; i &lt; this.cacheLimit) {
                    this.locations.push(data);
                }
            }
        }

        // deal with ignored locations
        if (splitCookie.length &gt; 1 &amp;&amp; splitCookie[1].length &gt; 0) {
            var ignored = splitCookie[1].split(&#x27;.&#x27;),
                ignoredLength = ignored.length;

            for (var i = 0; i &lt; ignoredLength; i++) {
                this.ignore(ignored[i]);
            }

        }

        this.reIndexLocations();
    };

    // Serialize locations cache and store it in a cookie
    locationsCache.persist = function() {
        // Define persistance interval checking variables
        var _this = this,
            persistInterval = 1000,
            persistWindow   = this.lastPersist + persistInterval,
            now             = parseInt((new Date().getTime()), 10);

        // if I am too close to the last time I persisted AND queue IS null
        if (persistWindow &gt; now &amp;&amp; this.queuePersist === null) {
            // queue a call to persist
            this.lastPersist = now;
            this.queuePersist = window.setTimeout(function(){_this.persist();}, persistInterval);
            log(&#x27;persist queued&#x27;);
            return;
        }
        // if I am too close to the last time I persisted AND queue IS NOT null
        else if (persistWindow &gt; now &amp;&amp; this.queuePersist !== null) {
            log(&#x27;persist ignored&#x27;);
            return;
        }
        // if I am safely past the required queue interval and queue IS NOT null
        else if (persistWindow &lt; now &amp;&amp; this.queuePersist !== null) {
            // Cleanup the queue flags if we can execute now
            window.clearTimeout(this.queuePersist);
            this.queuePersist = null;
            log(&#x27;persist queue cleared&#x27;);
        }
        else {
            // Nothing previously queued and no need to queue now
            log(&#x27;persist&#x27;);
        }

        // Record the time of our most recent persist
        this.lastPersist = now;

        // Define variable for use after dealing with the persistance checking
        var data = &#x27;&#x27;,
            ignored = &#x27;&#x27;,
            locsLength = this.locations.length,
            ignoreLength = this.ignoreLocations.length;

        // Add soft expiration interval and cached locations
        for (var i = 0; i &lt; locsLength; i++) {
            // Only persist up to the allowed cacheLimit
            if (i &gt;= this.cacheLimit) {
                break;
            }

            var loc = this.locations[i];

            if (data.length !== 0) {
                data += &#x27;.&#x27;;
            }

            data += loc.ntr + &quot;,&quot;
                  + loc.stn + &#x27;,&#x27;
                  + loc.sgn + &#x27;,&#x27;
                  + loc.et;
        }

        data = this.se + &#x27;.&#x27; + data;

        // Add ignored locations
        if (ignoreLength &gt; 0) {
            data += &#x27;|&#x27;;

            for (var i = 0; i &lt; ignoreLength; i++) {
                // Only persist up to the allowed cacheLimit
                if (i &gt;= this.cacheLimit) {
                    break;
                }

                if (ignored.length !== 0) {
                    ignored += &#x27;.&#x27;;
                }

                ignored += this.ignoreLocations[i];
            }

            data += ignored;
        }

        // Set cookie
        setCookie(&#x27;_st_l&#x27;, data);
    };

    // add a location to the cache
    locationsCache.add = function(locObj) {
        var reIndex = false,
            pushLength;

        // if this location is not already being ignored and is not already in cache
        if (!this.isIgnored(locObj.ntr)
            &amp;&amp; this.getIndex(locObj.ntr) === null) {
            // remove the oldest encountered location
            // NOT necessarily the location with the oldest expiration timestamp!!!
            if (this.locations.length === this.cacheLimit) {
                this.locations.shift();
                reIndex = true;
            }
            else if (this.locations.length &gt; this.cacheLimit) {
                // For now, silently fail on adding items above the cacheLimit
                log(&#x27;add - cacheLimit exceeded&#x27;);
                return;
            }

            // enforce expiration timestamp on every location added
            locObj.et = this.createExpiration();

            pushLength = this.locations.push(locObj);

            if (reIndex) {
                this.reIndexLocations();
            } else {
                this.updateIndex(locObj, pushLength-1);
            }
        }
    };

    // given a number, find the location object
    locationsCache.get = function(locStr) {
        var location = null;

        if (this.index.hasOwnProperty(locStr)) {
            location = this.locations[this.index[locStr]];
        }

        return location;
    };

    // given a number, find the location object&#x27;s index
    locationsCache.getIndex = function(locStr) {
        var locIndex = null;

        if (this.index.hasOwnProperty(locStr)) {
            locIndex = this.index[locStr];
        }

        return locIndex;
    };

    // Index a location and enable lookup by both its ntr and stn
    locationsCache.updateIndex = function(locObj, locIndex) {
        this.index[locObj.ntr] = locIndex;
        this.index[locObj.stn] = locIndex;

        this.persist();
    };

    // re-indexes the locations
    locationsCache.reIndexLocations = function() {
        this.index = {};

        for (var i = 0; i &lt; this.locations.length; i++) {
            var locObj = this.locations[i],
                locIndex = i;

            this.index[locObj.ntr] = locIndex;
            this.index[locObj.stn] = locIndex;
        }

        this.persist();
    };

    // create an expiration timestamp
    locationsCache.createExpiration = function() {
        return parseInt(((new Date().getTime()) / 1000) + parseInt(this.se, 10), 10);
    }

    // update a given location or array of loactions expirations
    locationsCache.updateExpiration = function(locArr) {
        // are we a single location or an array of locations?
        var locs = (typeof locArr === &#x27;string&#x27;) ? [locArr] : locArr,
            locsLength = locs.length;

        for (var i = 0; i &lt; locsLength; i++) {
            var locIndex = this.getIndex(locArr[i]);

            if (locIndex !== null) {
                this.locations[locIndex].et = this.createExpiration();
            }
        }

        this.persist();
    };

    // add a location to the list of ignored locations
    locationsCache.ignore = function(locStr) {
        // if not already ignored
        if (!this.isIgnored(locStr)) {
            // remove the oldest encountered ignored location
            // NOT necessarily the location with the oldest epiration timestamp!!!
            if (this.ignoreLocations.length === 20) {
                this.ignoreLocations.shift();
                reIndex = true;
            }

            this.ignoreLocations.push(locStr);
        }

        this.persist();
    };

    // determine if a location is being ignored
    locationsCache.isIgnored = function(locStr) {
        var isIgnored = false,
            iLLength = this.ignoreLocations.length;

        if (locStr == this.main.ntr
            || locStr == this.main.stn) {

            isIgnored = true;
        }
        else {
            for (var i = 0; i &lt; iLLength; i++) {
                if (this.ignoreLocations[i] == locStr) {
                    isIgnored = true;
                    break;
                }
            }
        }

        return isIgnored;
    };

    // removes all ignored locations from a given array of locations
    locationsCache.removeIgnoredLocations = function(locsArr) {
        var clean = [],
            locsArrLength = locsArr.length;

        for (var i = 0; i &lt; locsArrLength; i++) {
            if (!this.isIgnored(locsArr[i])) {
                clean.push(locsArr[i]);
            }
        }

        return clean;
    };

    // given an array of locations, returns true or false depending on
    // if the entire array of supplied locations can be found within the cache
    locationsCache.isCached = function(locsArr) {
        var locsArrLength = locsArr.length,
            found = true;

        for (var i = 0; i &lt; locsArrLength; i++) {
            var loc = locsArr[i];
            if (this.getIndex(loc) === null
                || this.isLocationExpired(loc)) {
                found = false;
                break;
            }
        }

        return found;
    };

    // given an array of numbers, return an object that matches
    // a payload from a request to the location endpoint
    locationsCache.craftCachePayload = function(locsArr) {
        var locsArrLength = locsArr.length,
            data = {
                se: this.se,
                mln: []
            };

        for (var i = 0; i &lt; locsArrLength; i++) {
            data.mln.push(this.get(locsArr[i]));
        }

        return data;
    };

    // determine if a given number has expired
    locationsCache.isLocationExpired = function(locStr) {
        var loc = this.get(locStr),
            now = parseInt((new Date().getTime()) / 1000, 10);

        return (loc === null) || (parseInt(loc.et, 10) &lt; now);
    };

    // only to be called on dom ready
    // returns an array of all numbers found on page
    function findLocations() {
        var r = new RegExp(&quot;(1[-. ]?)?\\(?(\\d{3})\\)?[-. ]?(\\d{3})[-. ]?(\\d{4})&quot;, &quot;g&quot;),
            matchText = document.title + &#x27; &#x27; + document.body.innerHTML,
            nums = matchText.match(r),
            numsIndex = {},
            uniques = [];

        for (var i = 0; i &lt; nums.length; i++) {
            num = nums[i].replace(/\D/g,&#x27;&#x27;);

            // Strip preceeding 1 from number string
            if (num.length === 11 &amp;&amp; num.charAt(0) === &#x27;1&#x27;) {
                num = num.substr(1);
            }

            // Ignore duplicates and only track unique numbers
            if (!numsIndex.hasOwnProperty(num)) {
                numsIndex[num] = 1;
                uniques.push(num);
            }
        }

        return uniques;
    }

    // prepares dom ready and cancels on non ML site
    function detectLocations() {
        // we have data and know we are not a multi location site, so just return
        if (d !== null &amp;&amp; d.ml !== 1) {
            return;
        }

        // find all phone numbers on the page as potential locations
        locationsFound = findLocations();

        // only proceed if there are locations found
        if (locationsFound.length === 0) {
            return;
        }
        else if (d !== null) {
            processLocations();
        }
        else {
            // standby for us to receive data from our inital number request
            locationsQueued = true;
        }
    }

    // we can assume this is always run after we have our initial d data object
    function processLocations() {
        // Initialize the locationsCache. This will build it from the cookie.
        locationsCache.init(d);

        locationsFound = locationsCache.removeIgnoredLocations(locationsFound);

        // if we have locations cached
        if (locationsCache.isCached(locationsFound)) {
            log(&#x27;Process Cached Locations&#x27;)
            _st.l(locationsCache.craftCachePayload(locationsFound), true);
        }
        else {
            // else refresh locations
            refreshLocations(locationsFound);
        }
    }

    // send a jsonp request to refresh the locations data
    function refreshLocations(locsArr) {
        var src = _st_locations_url + &#x27;?&#x27;
                + &quot;_stk=&quot; + _stk
                + &quot;&amp;bid=&quot; + d.bid
                + &quot;&amp;pid=&quot; + d.pid;

        src += &quot;&amp;mln=&quot; + JSON.stringify(locsArr);

        if (locsArr.length !== 0) {
            jsonpRequest(src);
        }
    }

    // src location for request
    function jsonpRequest (src) {
        if (!_st_sync) {
            var st = document.createElement(&#x27;script&#x27;),
                s  = document.getElementsByTagName(&#x27;script&#x27;)[0];

            st.type  = &#x27;text/javascript&#x27;;
            st.async = true;
            st.src   = src;

            // Add script node to page
            s.parentNode.insertBefore(st, s);
        } else {
            // write the synchronous number call to the page
            document.write(&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;&#x27; + src + &#x27;&quot;&gt;&lt;/script&gt;&#x27;);
        }
    }

    // render an array of location objects
    function renderLocations(mln) {
        var mlnLength = mln.length;
        for (var i = 0; i &lt; mlnLength; i++) {
            renderLocation(mln[i]);
        }
    }

    // render an individual location
    function renderLocation(locObj) {
        var ntr = splitPhone( (hasHardExpired ? locObj.stn : locObj.ntr) ),
            // Setup our regex that is used to search for a given number on the page and replace it with our ST number
            re = new RegExp(&quot;(1[-. ]?)?\\(?(&quot; + ntr[0] + &quot;)\\)?[-. ]?(&quot; + ntr[1] + &quot;)[-. ]?(&quot; + ntr[2] + &quot;)&quot;, &quot;g&quot;),
            // format the raw SourceTrak number in a nice readable manner for the screen. Optionally, wrap it in a tel anchor.
            rawNum = hasHardExpired ? locObj.ntr : locObj.stn,
            num = formatPhone(rawNum),
            ridEl,
            rcEl,
            rcElLength,
            jsReplace,
            strReplace;

        // figure out if we&#x27;re matching formats or using default
        if (_st_format) {
            // this one handles the callback for replace.js
            jsReplace = function (portion, match) {
                return matchFormat(portion.text, match[0], rawNum);
            };

            // this one is for the native String replace method
            strReplace = function (portion) {
                // for String.replace, the last argument is the full match term
                var match = arguments[arguments.length - 1];

                return matchFormat(portion, match, rawNum);
            };
        } else {
            jsReplace = strReplace = num;
        }

        // replace all instances of a specifed locations phone number on the page with the SourceTrak number
        var options  = {
                find: re,
                replace: jsReplace,
                rawNum: rawNum,
                wrapInATag: (d.a === 1 &amp;&amp; isMobile)
            },
            titleEls = _st.Sizzle(&#x27;[title]&#x27;),
            linkEls  = _st.Sizzle(&#x27;a[href*=&quot;tel&quot;]&#x27;);

        // replace in body
        _st.replace(document.body, options);

        // replace in page title
        document.title = document.title.replace(re, strReplace);

        // replace in title attributes
        for (var i = 0; i &lt; titleEls.length; i++) {
            var el    = titleEls[i],
                title = el.getAttribute(&#x27;title&#x27;);

            el.setAttribute(&#x27;title&#x27;, title.replace(re, strReplace));
        }

        // replace in tel links
        for (var j = 0; j &lt; linkEls.length; j++) {
            var el   = linkEls[j],
                href = el.getAttribute(&#x27;href&#x27;);

            el.setAttribute(&#x27;href&#x27;, href.replace(re, strReplace));
        }
    }

/******************************************
 * END LOCATIONS
 ******************************************/

    function setDataCookie() {
        setCookie(&#x27;_st&#x27;, serializeCookieData(d));
    }

    function setCookie(name, data) {
        var cookie = name + &quot;=&quot; + data;

        if (isCookieSupported &gt; 1) {
            cookie += &quot;;expires=&quot; + getCookieExpiresDate()
                    + &quot;;path=/&quot;
                    + &quot;;domain=&quot; + document.location.hostname;
        }
        log(&quot;SET &quot; + name + &quot; COOKIE&quot;);

        // set the cookie
        document.cookie = cookie;
    }

    function getCookie(name, deserialize) {
        var cookie = window._st.getCookie(name);

        if (cookie) {
            cookie = deserialize(cookie);
        } else {
            cookie = null;
        }

        return cookie;
    }

    // Returns a date 5 years in the furture
    // For use with cookie expires
    function getCookieExpiresDate(modifier) {
        var mydate = new Date();

        modifier = modifier !== undefined ? modifier : 5;

        // set date to 5 years in the future
        mydate.setYear(mydate.getFullYear() + modifier);

        return mydate.toUTCString();
    }

    function serializeCookieData(data) {
        // Only attempt to serialize UA if it exists. It is necessary to replace the period in the clientID
        // with a hyphen, as we use the period as a delimeter.
        return data.bid
            + &quot;.&quot; + data.pid
            + &quot;.&quot; + data.stn
            + &quot;.&quot; + data.sgn
            + &quot;.&quot; + data.ntr
            + &quot;.&quot; + data.rc
            + &quot;.&quot; + data.rid
            + &quot;.&quot; + data.et
            + &quot;.&quot; + data.ht
            + &quot;.&quot; + data.se
            + &quot;.&quot; + data.he
            + &quot;.&quot; + data.h
            + &quot;.&quot; + data.a
            + &quot;.&quot; + data.m
            + &quot;.&quot; + data.ml
            + &quot;.&quot; + data.v
            + &quot;.&quot; + data.sfx
            + (data.ua ? &quot;.&quot; + data.ua : &#x27;&#x27;)
            + (data.uac ? &quot;.&quot; + data.uac.replace(&#x27;.&#x27;, &#x27;-&#x27;, &#x27;gi&#x27;) : &#x27;&#x27;);
    }

    function deserializeCookieData(data) {
        var dataKeys = [&#x27;bid&#x27;, &#x27;pid&#x27;, &#x27;stn&#x27;, &#x27;sgn&#x27;, &#x27;ntr&#x27;, &#x27;rc&#x27;, &#x27;rid&#x27;, &#x27;et&#x27;, &#x27;ht&#x27;, &#x27;se&#x27;, &#x27;he&#x27;, &#x27;h&#x27;, &#x27;a&#x27;, &#x27;m&#x27;, &#x27;ml&#x27;, &#x27;v&#x27;, &#x27;sfx&#x27;, &#x27;ua&#x27;, &#x27;uac&#x27;],
            dataObj = {
                bid: null,  // browser id
                pid: null,  // property id
                stn: null,  // sourcetrak number
                sgn: null,  // sourceguard number flag (1|0)
                ntr: null,  // number to replace
                rc:  null,  // replace class
                rid: null,  // replace id
                et:  null,  // soft expires timestamp
                ht:  null,  // hard expires timestamp
                se:  null,  // soft expires interval
                he:  null,  // hard expires interval
                h:   null,  // heartbeat interval
                a:   null,  // anchor tag wrapping yes/no int
                m:   null,  // main number
                ml:  null,  // multi location
                v:   null,  // vanity number string
                sfx: null,  // phone suffix string
                ua:  null,  // google universal analytics trackerId
                uac: null   // google universal analytics clientId
            },
            dataArray = data.split(&#x27;.&#x27;),
            i = 0;

        for (; i &lt; dataArray.length; i++) {
            dataObj[dataKeys[i]] = dataArray[i];

            if (dataObj[dataKeys[i]] === &#x27;undefined&#x27; || dataObj[dataKeys[i]] === &#x27;NaN&#x27;) {
                dataObj[dataKeys[i]] = undefined;
            }

            // If UAC is present, replace our serialized version with proper clientID with period.
            // Also, set the ua and uac variables, and signal to future functions that UA has been set.
            if (dataKeys[i] === &#x27;uac&#x27;) {
                dataObj.uac = dataObj.uac.replace(&#x27;-&#x27;, &#x27;.&#x27;, &#x27;gi&#x27;);
                ua = dataObj.ua;
                uac = dataObj.uac;
                uaSet = true;
            }

            if (dataKeys[i] === &#x27;a&#x27; || dataKeys[i] === &#x27;ml&#x27;) {
                dataObj[dataKeys[i]] = parseInt(dataArray[i], 10);
            }
        }

        return dataObj;
    }

    function startHeartbeat() {
        stopHeartbeat();

        if (d !== null &amp;&amp; d.h !== null) {
            // multiply heartbeat time by 1000 to convert to milliseconds
            heartbeat = window.setInterval(beat, (d.h * 1000));
        }
    }

    function stopHeartbeat() {
        window.clearInterval(heartbeat);
    }

    function beat() {
        // check for hard expires
        var currentTime = getCurrentTimestamp(),
            data = {
                _stb: 1,
                bid: d.bid,
                pid: d.pid,
                stn: d.stn,
                sgn: d.sgn
            };

        if (d.ml === 1) {
            data.mln = JSON.stringify(locationsCache.rendered);
        }

        if (d.ht &lt; currentTime) {
            log(&#x27;hard expires on heartbeat, switching to main number&#x27;);

            // Stop heartbeating when a visitor remains on the page long enough to reach the hard expires limit
            stopHeartbeat();

            // Setting hasHardExpired will force the render functions to display main or ntr numbers
            hasHardExpired = true;

            // Revert the stn number to its domain default number (main)
            render();

            // Revert the location stns to their ntr
            renderLocations(locationsCache.renderedRawMln);
        }
        else if (d.et &lt; currentTime) {
            log(&#x27;soft expires on heartbeat, updating soft expires and refreshing number&#x27;);
            // update expires
            d.et = createExpiresTimestamp(d.se);

            refreshNumber();
            readyQueuePush(detectLocations);
        }
        else {
            // update expires
            d.et = createExpiresTimestamp(d.se);

            if (d.ml === 1) {
                locationsCache.updateExpiration(locationsCache.rendered);
            }

            setDataCookie();

            pushData(data, function () {
                log(&quot;beat&quot;);
            });
        }
    }

    function pushData(data, callback, noEncode) {
        var i = new Image(1, 1),
            p = noEncode ? &quot;?&quot; + data : encodeURLParams(data),
            cacheBuster = &#x27;&amp;cb=&#x27; + new Date().getTime(),
            stv = &#x27;&amp;stv=&#x27; + version,
            loadHandler = function () {
                // determine if success or failure
                log(&#x27;LOG SUCCESS&#x27;);

                if (callback !== undefined &amp;&amp; callback !== null) {
                    callback();
                }
            },
            errorHandler = function () {
                log(&#x27;LOG FAILURE&#x27;);
                log(&#x27;STOP HEARTBEAT&#x27;);
                stopHeartbeat();
            };

        i.onload  = loadHandler;
        i.onerror = errorHandler;
        i.src = _st_log_url + p + stv + cacheBuster;
        i = null;
    }

    function encodeURLParams(params) {
        var p = &quot;_stk=&quot; + _stk,
            key;

        for (key in params) {
            if (p.length &gt; 0) {
                p += &quot;&amp;&quot;;
            }
            p += encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(params[key]);
        }

        if (p.length &gt; 0) {
            p = &quot;?&quot; + p;
        }

        return p;
    }

    function refreshNumber() {
        var cacheBuster = &#x27;&amp;cb=&#x27; + new Date().getTime(),
            stv = &#x27;&amp;stv=&#x27; + version,
            src = _st_num_url + &quot;?&quot; + buildMeta() + stv + cacheBuster;

        // Explicitly flag when we record a page hit.
        // This is necessary information for making decisions about when to make a follow up with additional data.
        hasLoggedPageHit  = true;
        pageHitSuccessful = false;

        // Setup failure detection
        pageHitTimeout = window.setTimeout(function(){
            if (!pageHitSuccessful) {
                log(&#x27;FAILED REFRESH NUMBER CALL&#x27;);
                log(&#x27;STOP HEARTBEAT&#x27;);
                stopHeartbeat();
            }
        }, 10000);

        if (!_st_sync) {
            var st = document.createElement(&#x27;script&#x27;),
                s  = document.getElementsByTagName(&#x27;script&#x27;)[0];

            st.type  = &#x27;text/javascript&#x27;;
            st.async = true;
            st.src   = src;

            // Add script node to page
            s.parentNode.insertBefore(st, s);
        } else {
            // write the synchronous number call to the page
            document.write(&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;&#x27; + src + &#x27;&quot;&gt;&lt;/script&gt;&#x27;);
        }
    }

    // Dispatch our request to the Google Universal Analytics function.
    // If it has not yet loaded on the page, try again in 2 seconds, up to 15 times.
    // This is necessary in situations where our scripts are loaded before google analytics, as Universal Analytics
    // did away with the _gaq event queue that could be pushed to before analytics loads.
    function dispatchUA() {
        if (typeof ga !== &quot;undefined&quot;) {
            uaDispatched = true;
            log(&#x27;UA Dispatched&#x27;);
            ga(function () {
                var tracker = ga.getAll()[0];
                window._st.setUA(tracker.get(&#x27;trackingId&#x27;), tracker.get(&#x27;clientId&#x27;));
            });
        } else if (dispatchCount &lt; 15) {
            window.setTimeout(dispatchUA, 2000);
            dispatchCount++;
        }
    }

    // If the analytics has to be logged in a seperate request, ensure that it is always logged AFTER the page hit
    // and has all the necessary information to attribute it to a visitor and their browsing session
    function pushUA() {
        pushData({
                _stlu: 1,
                bid: d.bid,
                pid: d.pid,
                stn: d.stn,
                ua: d.ua,
                uac: d.uac
            },
            function(){
                log(&quot;log analytics&quot;);
            }
        );

        hasLoggedPageHitWithUA = true;
    }

    function dispatchIntegrations(integrations) {
        // cache length since we alter it in the loop
        var l = integrations.length,
            completedIntegrations = 0;

        for (var i = 0; i &lt; l; i++) {
            var integration = integrations[i];

            // see if this integration finished in a previous interval
            if (integration.found()) {
                completedIntegrations++;
            } else {
                log(&#x27;searching for integration: &#x27; + integration.name());

                integration.fetch(setIntegrationData);
            }
        }

        // send any data we found this interval
        if (integrationsData.length) {
            pushIntegrationData(integrationsData);
        }

        // wait 2 seconds, then try again for the ones we haven&#x27;t found yet
        // time out after 15 tries/30 seconds
        if (completedIntegrations &lt; integrations.length &amp;&amp; integrationsCount &lt; 15) {
            log(&#x27;retry integrations dispatch in 2 seconds&#x27;);

            window.setTimeout(function () {
                dispatchIntegrations(integrations);
            }, 2000);

            integrationsCount++;
        } else {
            log(&#x27;finished integrations: sent &#x27; + completedIntegrations + &#x27; of &#x27; + integrations.length);
        }
    }

    function setIntegrationData (data) {
        integrationsData.push(data);
    }

    function pushIntegrationData (data) {
        var stData = {
                _stli: 1,
                bid: d.bid,
                pid: d.pid,
                stn: d.stn
            },
            maxLength = (2083 - _st_log_url.length - encodeURLParams(stData).length),
            encodedData = btoa(JSON.stringify(data));

        // if data is too big to put in a GET request, we need to break it down
        if (encodedData.length &gt; maxLength) {
            // if we&#x27;re working with more than integration
            if (data.length &amp;&amp; data.length &gt; 1) {
                // push each integration separately, wrapping the data in an array
                for (var i = 0; i &lt; data.length; i++) {
                    pushIntegrationData([data[i]]);
                }
            } else {
                // this is a single integration object and it&#x27;s still too big
                // not much we can do

                log(&#x27;Unable to send &#x27; + data[0].name + &#x27;. Data exceeds maximum size.&#x27;);

                //remove this data from the collection to be sent
                for (var i = 0; i &lt; integrationsData.length; i++) {
                    var integration = integrationsData[i];

                    if (data[0] === integration) {
                        integrationsData.splice(i, 1);
                    }
                }
            }

            return;
        }

        // send integration data
        stData.integrations = encodedData;

        pushData(stData,
        function () {
            log(&#x27;pushing integration data&#x27;);
        });

        // reset data
        integrationsData.length = 0;
    }

    function detectMobile() {
        isMobile = navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i) ? true : false;
    }

    function createConsoleEl() {
        var $body    = document.getElementsByTagName(&#x27;body&#x27;)[0],
            $console = document.createElement(&#x27;div&#x27;),
            style    = &quot;background-color: #FFF; position: fixed; bottom: 0px;&quot;
                        + &quot;height: 700px; width: 800px; margin: 0px -400px 0px -400px;&quot;
                        + &quot;left: 50%; right: 50%; border: 2px solid red; overflow-y: scroll;&quot;,
            logEntry = &quot;&lt;b style=&#x27;color:red;&#x27;&gt;SOURCETRACK DEBUG MODE ENABLED: OUTPUT LOG&lt;/b&gt;&quot;;

        $console.setAttribute(&quot;id&quot;, &quot;_st_log&quot;);
        $console.setAttribute(&quot;style&quot;, style);
        $body.appendChild($console, $body);

        $console.appendChild(createLogEntryEl(logEntry), $console);

        return $console;
    }

    function createLogEntryEl(data) {
        var $output = document.createElement(&#x27;div&#x27;),
            re      = /,/gi, // Must use real regex for replace due to ios bug
            style   = &quot;line-height: 14px; border-bottom: 1px solid #999; padding: 2px;&quot;
                        + &quot;font-size: 11px; font-family: sans-serif; width 796px;&quot;;

        $output.setAttribute(&quot;style&quot;, style);

        $output.innerHTML = (typeof data === &quot;string&quot;) ? data : JSON.stringify(data).replace(re, &#x27;, &#x27;);

        return $output;
    }

    function log() {
        if (isMobile === undefined) {
            detectMobile();
            log(navigator.userAgent);
            log(&quot;Cookie Support: &quot; + verifyCookieSupport());
        }

        if (_st_debug) {
            // Only use console on non-mobile devices
            // document.addEventListener feature detection to restrict console to IE9+
            // as IE8 has a broken implementation
            if (!isMobile
                &amp;&amp; typeof console !== &quot;undefined&quot;
                &amp;&amp; typeof console.log !== &quot;undefined&quot;
                &amp;&amp; typeof console.log.apply !== &quot;undefined&quot;
                &amp;&amp; document.addEventListener) {
                    console.log.apply(console, arguments);
            } else {
                var $console = _st.Sizzle(&#x27;#_st_log&#x27;)[0];

                if ($console === undefined) {
                    $console = createConsoleEl();
                }

                $console.appendChild(createLogEntryEl(arguments[0]), $console);
                $console.scrollTop = $console.scrollHeight;
            }
        }
    }

    // Check for cookie support, both persistent and session
    // return int   2 for full support, 1 for only session support, 0 for no support
    // TODO: remove test cookie by setting past expiration
    function verifyCookieSupport() {
        var cookie = &quot;_stc=1&quot;;

        // Check for persistent cookie functionality
        document.cookie = cookie + &quot;;expires=&quot; + getCookieExpiresDate();

        // if the persistent cookie exists, return 2 for full cookie support
        if (document.cookie.indexOf(cookie) &gt;= 0) {
            isCookieSupported = 2;

            // attempt to remove the test cookie
            document.cookie = cookie + &quot;;expires=&quot; + getCookieExpiresDate(-1);
            return 2;
        }

        // If we are here then the persistent cookie failed
        // Now try and set a session cookie
        document.cookie = cookie;

        // if the session cookie exists, return 1 for partial cookie support
        if (document.cookie.indexOf(cookie) &gt;= 0) {
            isCookieSupported = 2;
            return 1;
        }

        // no cookie support
        isCookieSupported = 0;
        return 0;
    }

    function executeReadyQueue() {
        var queue = readyQueue;
        readyQueue = [];

        for (var i = 0; i &lt; queue.length; i++) {
            queue[i]();
        }
    }

    function readyQueuePush(callback) {
        readyQueue.push(callback);

        if (_st.ready.isReady) {
            executeReadyQueue();
        }
    }

    function appInit () {
        if (verifyCookieSupport()) {
            var cookie = getCookie(&#x27;_st&#x27;, deserializeCookieData);

            // If Google Universal Analytics is on the page, get the Tracker ID and the clientID
            // This may be looged in a seperate follow up request, due to the async nature of GUA
            if (cookie) {
                if (!cookie.ua) {
                    dispatchUA();
                }

                // Cookie has been set, so render first then ping with metadata
                log(&quot;RUNNING OFF COOKIE&quot;);
                _st.i(cookie, true);
            } else {
                dispatchUA();
                log(&quot;NO COOKIE, MAKING REQUEST FOR NUMBER&quot;);
                refreshNumber();
            }

            readyQueuePush(detectLocations);

            _st.ready(executeReadyQueue);
        }
    }

    // immediately intialize sourcetrak
    appInit();
})(window);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
